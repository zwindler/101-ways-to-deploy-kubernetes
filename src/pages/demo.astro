---
// Demo page to showcase the SolutionCard component with FilterBar and SearchBar
import Layout from "../layouts/Layout.astro";
import SolutionCard from "../components/SolutionCard.astro";
import FilterBar from "../components/FilterBar.astro";
import SearchBar from "../components/SearchBar.astro";
import { readFileSync } from "node:fs";
import { load } from "js-yaml";
import { join } from "node:path";

// Load solutions from YAML file
const yamlPath = join(process.cwd(), "data", "solutions.yaml");
const yamlContent = readFileSync(yamlPath, "utf8");
const data = load(yamlContent) as { solutions: any[] };
const allSolutions = data.solutions || [];

// Extract unique categories from solutions
const categories = [
  "Desktop",
  "IaC",
  "KubernetesInKubernetes",
  "KubernetesOS",
  "Managed",
  "ManagementPlatform",
  "Other",
  "Selfhosted",
];

// Define cloud providers
const cloudProviders = [
  "aws",
  "gcp",
  "azure",
  "civo",
  "digitalocean",
  "scaleway",
  "ovh",
  "hetzner",
  "linode",
  "vultr",
  "oracle",
  "ibm",
  "alibaba",
];

// Extract unique tags
const tags = [...new Set(allSolutions.flatMap(s => s.tags || []))].sort();
---

<Layout title="Kubernetes Deployment Solutions">
  <div class="bg-gray-100 dark:bg-gray-900 min-h-screen">
    <div class="container mx-auto px-4 py-12">
      <!-- Header -->
      <div class="mb-8 text-center">
        <h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-4">
          Kubernetes Deployment Solutions
        </h1>
        <p class="text-gray-600 dark:text-gray-400 mb-6">
          Browse and filter {allSolutions.length} ways to deploy Kubernetes
        </p>
        <!-- Dark Mode Toggle -->
        <button
          id="darkModeToggle"
          class="px-4 py-2 bg-gray-800 dark:bg-gray-200 text-white dark:text-gray-900 rounded-lg hover:bg-gray-700 dark:hover:bg-gray-300 transition-colors"
        >
          Toggle Dark Mode
        </button>
      </div>

      <!-- Filter Bar -->
      <FilterBar categories={categories} cloudProviders={cloudProviders} tags={tags} />

      <!-- Search Bar -->
      <SearchBar />

      <!-- Cards Grid -->
      <div
        id="solutions-grid"
        class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
      >
        {
          allSolutions.map((solution) => (
            <SolutionCard solution={solution} />
          ))
        }
      </div>

      <!-- No results message -->
      <div
        id="no-results"
        class="hidden text-center py-12 text-gray-600 dark:text-gray-400"
      >
        <svg
          class="w-16 h-16 mx-auto mb-4 text-gray-400"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
          ></path>
        </svg>
        <p class="text-lg font-medium">No solutions found</p>
        <p class="text-sm">Try adjusting your filters</p>
      </div>

      <!-- Legend -->
      <div class="mt-12 bg-white dark:bg-gray-800 rounded-lg shadow-md p-6">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-4">
          Features
        </h2>
        <div class="grid md:grid-cols-3 gap-4">
          <div>
            <h3 class="font-semibold text-gray-900 dark:text-white mb-2">
              SearchBar Component
            </h3>
            <ul class="space-y-1 text-sm text-gray-600 dark:text-gray-400">
              <li>✅ Real-time search</li>
              <li>✅ Debounced input (150ms)</li>
              <li>✅ Clear button</li>
              <li>✅ Results counter</li>
              <li>✅ Keyboard shortcuts (/ to focus)</li>
              <li>✅ Search across all fields</li>
              <li>✅ Works with FilterBar</li>
              <li>✅ Dark mode support</li>
            </ul>
          </div>
          <div>
            <h3 class="font-semibold text-gray-900 dark:text-white mb-2">
              FilterBar Component
            </h3>
            <ul class="space-y-1 text-sm text-gray-600 dark:text-gray-400">
              <li>✅ Category filter pills</li>
              <li>✅ Cloud provider dropdown</li>
              <li>✅ Open source filter toggle</li>
              <li>✅ Status checkboxes</li>
              <li>✅ Clear all filters button</li>
              <li>✅ Real-time filtering</li>
              <li>✅ Dark mode support</li>
              <li>✅ Responsive design</li>
            </ul>
          </div>
          <div>
            <h3 class="font-semibold text-gray-900 dark:text-white mb-2">
              SolutionCard Component
            </h3>
            <ul class="space-y-1 text-sm text-gray-600 dark:text-gray-400">
              <li>✅ Modern card design</li>
              <li>✅ Status badges</li>
              <li>✅ Open source badge</li>
              <li>✅ Based on section</li>
              <li>✅ Tags section</li>
              <li>✅ License and references</li>
              <li>✅ GitHub link detection</li>
              <li>✅ Responsive grid layout</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Dark mode toggle functionality
      const darkModeToggle = document.getElementById("darkModeToggle");
      const html = document.documentElement;

      darkModeToggle?.addEventListener("click", () => {
        html.classList.toggle("dark");
      });

      // Initialize dark mode based on system preference
      if (
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches
      ) {
        html.classList.add("dark");
      }

      // Filter solutions based on filter state
      let currentSearchQuery = "";
      let currentFilterState = {
        category: "all",
        cloudProvider: "",
        openSourceOnly: false,
        statuses: ["active"],
        tags: [] as string[]
      };

      function applyCombinedFilters() {
        // Get all solution cards
        const solutionsGrid = document.getElementById("solutions-grid");
        const noResults = document.getElementById("no-results");
        if (!solutionsGrid) return;

        const cards = Array.from(solutionsGrid.children) as HTMLElement[];
        const solutions = JSON.parse(
          document.getElementById("solutions-data")?.textContent || "[]"
        );
        let visibleCount = 0;

        cards.forEach((card, index) => {
          const solution = solutions[index];
          if (!solution) return;

          // Extract solution data from card (stored in data attributes)
          const solutionData = {
            category: card.dataset.category || "",
            cloudProviders: (card.dataset.cloudProviders || "").split(",").filter(Boolean),
            openSource: card.dataset.openSource === "true",
            abandoned: card.dataset.abandoned === "true",
            name: solution.name || "",
            publisher: solution.publisher || "",
            description: solution.description || "",
            tags: solution.tags || [],
            based_on: solution.based_on || [],
          };

          // Apply filter bar filters
          let visible = true;

          // Category filter
          if (currentFilterState.category !== "all" && solutionData.category !== currentFilterState.category) {
            visible = false;
          }

          // Cloud provider filter (only for Managed/IaC)
          if (
            currentFilterState.cloudProvider &&
            (currentFilterState.category === "Managed" || currentFilterState.category === "IaC")
          ) {
            if (!solutionData.cloudProviders.includes(currentFilterState.cloudProvider)) {
              visible = false;
            }
          }

          // Open source filter
          if (currentFilterState.openSourceOnly && !solutionData.openSource) {
            visible = false;
          }

          // Status filter
          if (currentFilterState.statuses.length > 0) {
            const itemStatus = solutionData.abandoned ? 'abandoned' : 'active';
            if (!currentFilterState.statuses.includes(itemStatus)) {
              visible = false;
            }
          }

          // Tags filter
          if (visible && currentFilterState.tags.length > 0) {
            const itemTags = (solutionData.tags || []).map((t: string) => t.toLowerCase());
            const normalizedFilterTags = currentFilterState.tags.map((t: string) => t.toLowerCase());
            if (!normalizedFilterTags.some((tag: string) => itemTags.includes(tag))) {
              visible = false;
            }
          }

          // Apply search filter
          if (visible && currentSearchQuery) {
            const searchableText = [
              solutionData.name,
              solutionData.category,
              solutionData.publisher,
              solutionData.description,
              ...(solutionData.tags || []),
              ...(solutionData.based_on || []),
            ].filter(Boolean).join(' ').toLowerCase();
            
            if (!searchableText.includes(currentSearchQuery)) {
              visible = false;
            }
          }

          // Show/hide card
          if (visible) {
            card.classList.remove("hidden");
            visibleCount++;
          } else {
            card.classList.add("hidden");
          }
        });

        // Show/hide no results message
        if (noResults) {
          if (visibleCount === 0) {
            noResults.classList.remove("hidden");
          } else {
            noResults.classList.add("hidden");
          }
        }

        // Update search counter
        window.dispatchEvent(new CustomEvent('solutions-count-update', {
          detail: { count: visibleCount }
        }));
      }

      document.addEventListener("filter-change", (event: Event) => {
        const customEvent = event as CustomEvent;
        currentFilterState = customEvent.detail;
        console.log("Filter state changed:", currentFilterState);
        applyCombinedFilters();
      });

      // Listen for search-change event from SearchBar
      window.addEventListener('search-change', ((event: CustomEvent) => {
        currentSearchQuery = event.detail.query;
        console.log("Search query changed:", currentSearchQuery);
        applyCombinedFilters();
      }) as EventListener);

      // Add data attributes to solution cards for filtering
      window.addEventListener("DOMContentLoaded", () => {
        const solutionsGrid = document.getElementById("solutions-grid");
        if (!solutionsGrid) return;

        const cards = Array.from(solutionsGrid.children) as HTMLElement[];
        const solutions = JSON.parse(
          document.getElementById("solutions-data")?.textContent || "[]"
        );

        cards.forEach((card, index) => {
          const solution = solutions[index];
          if (solution) {
            card.dataset.category = solution.category || "";
            card.dataset.cloudProviders = (solution.cloud_providers || []).join(",");
            card.dataset.openSource = String(solution.open_source || false);
            card.dataset.abandoned = String(solution.abandoned || false);
          }
        });
      });
    </script>

    <!-- Store solutions data for filtering -->
    <script id="solutions-data" type="application/json" is:inline set:html={JSON.stringify(allSolutions)} />
  </div>
</Layout>
